{"/home/travis/build/npmtest/node-npmtest-numbers/test.js":"/* istanbul instrument in package npmtest_numbers */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-numbers/lib.npmtest_numbers.js":"/* istanbul instrument in package npmtest_numbers */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_numbers = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_numbers = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-numbers/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-numbers && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_numbers */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_numbers\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_numbers.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_numbers.rollup.js'] =\n            local.assetsDict['/assets.npmtest_numbers.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_numbers.__dirname + '/lib.npmtest_numbers.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/index.js":"module.exports = require('./lib/numbers.js');\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers.js":"/**\n * numbers.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar numbers = exports;\n\n\n// Expose methods\nnumbers.basic = require('./numbers/basic');\nnumbers.calculus = require('./numbers/calculus');\nnumbers.complex = require('./numbers/complex');\nnumbers.dsp = require('./numbers/dsp');\nnumbers.matrix = require('./numbers/matrix');\nnumbers.prime = require('./numbers/prime');\nnumbers.statistic = require('./numbers/statistic');\nnumbers.generate = require('./numbers/generators');\nnumbers.random = require('./numbers/random');\n\n/**\n * @property {Number} EPSILON Epsilon (error bound) to be used\n * in calculations. Can be set and retrieved freely.\n *\n * Given the float-point handling by JavaScript, as well as\n * the numbersal proficiency of some methods, it is common\n * practice to include a bound by which discrepency between\n * the \"true\" answer and the returned value is acceptable.\n *\n * If no value is provided, 0.001 is default.\n */\nnumbers.EPSILON = 0.001;\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/basic.js":"/**\n * basic.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar basic = exports;\n\n/**\n * Determine the summation of numbers in a given array.\n *\n * @param {Array} collection of numbers.\n * @return {Number} sum of numbers in array.\n */\nbasic.sum = function (arr) {\n  if (Object.prototype.toString.call(arr) === '[object Array]') {\n    var total = 0;\n    for (var i = 0 ; i < arr.length ; i++) {\n      if (typeof(arr[i]) === 'number') {\n        total = total + arr[i];\n      } else {\n        throw new Error('All elements in array must be numbers');\n      }\n    }\n    return total;\n  } else {\n    throw new Error('Input must be of type Array');\n  }\n};\n\n/**\n * Subtracts elements from one another in array.\n *\n * e.g [5,3,1,-1] -> 5 - 3 - 1 - (-1) = 2\n *\n * @param {Array} collection of numbers.\n * @return {Number} difference.\n */\nbasic.subtraction = function (arr) {\n  if (Object.prototype.toString.call(arr) === '[object Array]') {\n    var total = arr[0];\n    if (typeof(total) !== 'number') {\n      throw new Error('All elements in array must be numbers');\n    }\n    for (var i = 1, length = arr.length; i < length; i++) {\n      if (typeof(arr[i]) === 'number') {\n        total -= arr[i];\n      } else {\n        throw new Error('All elements in array must be numbers');\n      }\n    }\n    return total;\n  } else {\n    throw new Error('Input must be of type Array');\n  }\n};\n\n/**\n * Product of all elements in an array.\n *\n * @param {Array} collection of numbers.\n * @return {Number} product.\n */\nbasic.product = function (arr) {\n  if (Object.prototype.toString.call(arr) === '[object Array]') {\n    var total = arr[0];\n    if (typeof(total) !== 'number') {\n      throw new Error('All elements in array must be numbers');\n    }\n    for (var i = 1, length = arr.length; i < length; i++) {\n      if (typeof(arr[i]) === 'number') {\n        total = total * arr[i];\n      } else {\n        throw new Error('All elements in array must be numbers');\n      }\n    }\n    return total;\n  } else {\n    throw new Error('Input must be of type Array');\n  }\n};\n\n/**\n * Return the square of any value.\n *\n * @param {Number} number\n * @return {Number} square of number\n */\nbasic.square = function (num) {\n  if (typeof(num) !== 'number') {\n    throw new Error('Input must be a number.');\n  } else {\n    return num * num;  \n  }\n  \n};\n\n/**\n * Calculate the binomial coefficient (n choose k)\n *\n * @param {Number} available choices\n * @param {Number} number chosen\n * @return {Number} number of possible choices\n */\nbasic.binomial = function (n, k) {\n\n  var arr = [];\n\n  function _binomial (n, k) {\n    if (typeof(n) !== 'number' && typeof(k) !== 'number') {\n      throw new Error('Input must be a number.');\n    }\n    if (n >= 0 && k === 0) return 1;\n    if (n === 0 && k > 0) return 0;\n    if (arr[n] && arr[n][k] > 0) return arr[n][k];\n    if (!arr[n]) arr[n] = [];\n\n    arr[n][k] = _binomial(n - 1, k - 1) + _binomial(n - 1, k);\n    return arr[n][k];\n  }\n\n  return _binomial(n, k);\n};\n\n/**\n * Factorial for some integer.\n *\n * @param {Number} integer.\n * @return {Number} result.\n */\nbasic.factorial = function (num){\n  if(typeof(num) !== 'number') throw new Error(\"Input must be a number.\");\n  if(num < 0) throw new Error(\"Input must not be negative.\");\n  var i = 2, o = 1;\n  \n  while (i <= num) {\n    o *= i++;\n  }\n\n  return o;\n};\n\n/**\n * Calculate the greastest common divisor amongst two integers.\n * \n * @param {Number} number A.\n * @param {Number} number B.\n * @return {Number} greatest common divisor for integers A, B.\n */\nbasic.gcd = function (a, b) {\n  var c;\n  a = +a;\n  b = +b;\n  // Same as isNaN() but faster\n  if (a !== a || b !== b) {\n    return NaN;\n  }\n  //Same as !isFinite() but faster\n  if (a === Infinity || a === -Infinity || b === Infinity || b === -Infinity) {\n    return Infinity;\n  }\n  // Checks if a or b are decimals\n  if ((a % 1 !== 0) || (b % 1 !== 0)) {\n    throw new Error(\"Can only operate on integers\");\n  }\n  while (b) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return (0 < a) ? a : -a;\n};\n\n/**\n * Calculate the least common multiple amongst two integers.\n *\n * @param {Number} number A.\n * @param {Number} number B.\n * @return {Number} least common multiple for integers A, B.\n */\nbasic.lcm = function (num1, num2) {\n  return Math.abs(num1 * num2) / basic.gcd(num1, num2);\n};\n\n/**\n * Retrieve a specified quantity of elements from an array, at random.\n *\n * @param {Array} set of values to select from.\n * @param {Number} quantity of elements to retrieve.\n * @param {Boolean} allow the same number to be returned twice.\n * @return {Array} random elements.\n */\nbasic.random = function (arr, quant, allowDuplicates) {\n  if (arr.length === 0){\n    throw new Error('Empty array');\n  } else if (quant > arr.length  && !allowDuplicates){\n    throw new Error('Quantity requested exceeds size of array');\n  }\n  \n  if (allowDuplicates === true) {\n    var result = [], i;\n    for (i = 0; i < quant; i++) {\n      result[i] = arr[Math.floor(Math.random() * arr.length)];\n    }\n    return result;    \n  } else {\n    return basic.shuffle(arr).slice(0, quant);\n  }\n};\n\n/**\n * Shuffle an array, in place.\n *\n * @param {Array} array to be shuffled.\n * @return {Array} shuffled array.\n */\nbasic.shuffle = function (array) {\n  var m = array.length, t, i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n};\n\n/**\n * Find maximum value in an array.\n *\n * @param {Array} array to be traversed.\n * @return {Number} maximum value in the array.\n */\nbasic.max = function (arr) {\n  if (!Array.isArray(arr)) {\n    throw new Error(\"Input must be of type Array\");\n  }\n  var max = -Infinity, val;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    val = +arr[i];\n    if (max < val) {\n      max = val;\n    }\n    // Math.max() returns NaN if one of the elements is not a number.\n    if( val !== val ){\n      return NaN;\n    }\n  }\n  return max;\n};\n\n/**\n * Find minimum value in an array.\n *\n * @param {Array} array to be traversed.\n * @return {Number} minimum value in the array.\n */\nbasic.min = function (arr) {\n  if (!Array.isArray(arr)) {\n    throw new Error(\"Input must be of type Array\");\n  }\n  var min = +Infinity, val;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    val = +arr[i];\n    if (val < min) {\n      min = val;\n    }\n    // Math.min() returns NaN if one of the elements is not a number.\n    if( val !== val ){\n      return NaN;\n    }\n  }\n  return min;\n};\n\n\n/**\n * Create a range of numbers.\n *\n * @param {Number} The start of the range.\n * @param {Number} The end of the range.\n * @return {Array} An array containing numbers within the range.\n */\nbasic.range = function (start, stop, step) {\n  var array, i = 0, len;\n\n  if (arguments.length <= 1) {\n    stop = start || 0;\n    start = 0;\n  }\n\n  step = step || 1;\n\n  if (stop < start) {\n    step = 0 - Math.abs(step);\n  }\n\n  len = Math.max(Math.ceil((stop - start) / step) + 1, 0);\n\n  array = new Array(len);\n\n  while (i < len) {\n    array[i++] = start;\n    start += step;\n  }\n\n  return array;\n};\n\n/**\n  * Determine if the number is an integer.\n  *\n  * @param {Number} the number\n  * @return {Boolean} true for int, false for not int.\n  */\nbasic.isInt = function (n) {\n  return n % 1 === 0;\n};\n\n/**\n  * Calculate the divisor and modulus of two integers.\n  *\n  * @param {Number} int a.\n  * @param {Number} int b.\n  * @return {Array} [div, mod].\n  */\nbasic.divMod = function (a, b) {\n  if(b <= 0) throw new Error(\"b cannot be zero. Undefined.\");\n  if (!basic.isInt(a) || !basic.isInt(b)) throw new Error(\"A or B are not integers.\");\n  return [Math.floor(a / b), a % b];\n};\n\n/**\n  * Calculate:\n  * if b >= 1: a^b mod m.\n  * if b = -1: modInverse(a, m).\n  * if b < 1: finds a modular rth root of a such that b = 1/r.\n  *\n  * @param {Number} Number a.\n  * @param {Number} Number b.\n  * @param {Number} Modulo m.\n  * @return {Number} see the above documentation for return values.\n  */\nbasic.powerMod = function (a, b, m) {\n  if(typeof(a) !== 'number' || typeof(b) !== 'number' || typeof(m) !== 'number') throw new Error(\"Inputs must be numbers.\");\n  // If b < -1 should be a small number, this method should work for now.\n  if (b < -1) return Math.pow(a, b) % m; \n  if (b === 0) return 1 % m;\n  if (b >= 1) {\n    var result = 1;\n    while (b > 0) {\n      if ((b % 2) === 1) {\n        result = (result * a) % m;\n      }\n      \n      a = (a * a) % m;\n      b = b >> 1;\n    }\n    return result;\n  }\n\n  if (b === -1) return basic.modInverse(a, m);\n  if (b < 1) {\n    return basic.powerMod(a, Math.pow(b, -1), m); \n  }\n};\n\n/**\n * Calculate the extended Euclid Algorithm or extended GCD.\n *\n * @param {Number} int a.\n * @param {Number} int b.\n * @return {Array} [a, x, y] a is the GCD. x and y are the values such that ax + by = gcd(a, b) .\n */\nbasic.egcd = function (a, b) {\n  a = +a;\n  b = +b;\n  // Same as isNaN() but faster\n  if (a !== a || b !== b) {\n    return [NaN, NaN, NaN];\n  }\n  //Same as !isFinite() but faster\n  if (a === Infinity || a === -Infinity || b === Infinity || b === -Infinity) {\n    return [Infinity, Infinity, Infinity];\n  }\n  // Checks if a or b are decimals\n  if ((a % 1 !== 0) || (b % 1 !== 0)) {\n    throw new Error(\"Can only operate on integers\");\n  }\n  var signX = (a < 0) ? -1 : 1,\n      signY = (b < 0) ? -1 : 1,\n      x = 0,\n      y = 1,\n      oldX = 1,\n      oldY = 0,\n      q, r, m, n;\n    a = Math.abs(a);\n    b = Math.abs(b);\n\n  while(a !== 0){\n    q = Math.floor(b/a);\n    r = b % a;\n    m = x - oldX*q;\n    n = y - oldY*q;\n    b = a;\n    a = r;\n    x = oldX;\n    y = oldY;\n    oldX = m;\n    oldY = n;\n  }\n  return [b, signX*x, signY*y];\n};\n/**\n  * Calculate the modular inverse of a number.\n  *\n  * @param {Number} Number a.\n  * @param {Number} Modulo m.\n  * @return {Number} if true, return number, else throw error.\n  */\nbasic.modInverse = function (a, m) {\n  var r = basic.egcd(a, m);\n  if (r[0] != 1) throw new Error('No modular inverse exists');\n  return r[1] % m;\n};\n\n\n/**\n * Determine is two numbers are equal within a given margin of precision.\n *\n * @param {Number} first number.\n * @param {Number} second number.\n * @param {Number} epsilon.\n */\nbasic.numbersEqual = function(first, second, epsilon) {\n  if(typeof(first) !== 'number' || typeof(second) !== 'number' || typeof(epsilon) !== 'number') throw new Error(\"First and Second must be numbers.\");\n  return (first - second) < epsilon && (first - second) > -epsilon;\n};\n\n/**\n * Calculate the falling factorial of a number\n *\n * {@see http://mathworld.wolfram.com/FallingFactorial.html}\n *\n * @param {Number} Base\n * @param {Number} Steps to fall\n * @returns {Number} Result\n */\nbasic.fallingFactorial = function(n, k) {\n  var i = (n-k+1), r = 1;\n  \n  if(n<0) { throw new Error(\"n cannot be negative.\"); }\n  if(k>n) { throw new Error(\"k cannot be greater than n.\"); }\n  \n  while(i <= n) {\n    r *= i++;\n  }\n\n  return r;\n};\n\n/**\n * Calculate the permutation (n choose k)\n *\n * @param {Number} available choices\n * @param {Number} number chosen\n * @return {Number} number of ordered variations\n */\n\nbasic.permutation = function(n, k) {\n    if (n <= 0) {\n        throw new Error(\"n cannot be less than or equal to 0.\");\n    }\n    if (n < k) {\n        throw new Error(\"k cannot be greater than k.\");\n    }\n    var binomial = basic.binomial(n, k);\n    var permutation = binomial * basic.factorial(k);\n    return permutation;\n};\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/calculus.js":"/**\n * calculus.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar numbers = require('../numbers');\nvar calculus = exports;\n\n/**\n * Calculate point differential for a specified function at a\n * specified point.  For functions of one variable.\n *\n * @param {Function} math function to be evaluated.\n * @param {Number} point to be evaluated.\n * @return {Number} result.\n */\ncalculus.pointDiff = function (func, point) {\n  var a = func(point - 0.001);\n  var b = func(point + 0.001);\n\n  return (b - a) / (0.002);\n};\n\n/**\n * Calculate riemann sum for a specified, one variable, function\n * from a starting point, to a finishing point, with n divisions.\n *\n * @param {Function} math function to be evaluated.\n * @param {Number} point to initiate evaluation.\n * @param {Number} point to complete evaluation.\n * @param {Number} quantity of divisions.\n * @param {Function} (Optional) Function that returns which value \n *   to sample on each interval; if none is provided, left endpoints\n *   will be used.\n * @return {Number} result.\n */\ncalculus.Riemann = function (func, start, finish, n, sampler) {\n  var inc = (finish - start) / n;\n  var totalHeight = 0;\n  var i;\n  \n  if (typeof sampler === 'function') {\n    for (i = start; i < finish; i += inc) {\n      totalHeight += func(sampler(i, i + inc));\n    }\n  } else {\n    for (i = start; i < finish; i += inc) {\n      totalHeight += func(i);\n    }\n  }\n  \n  return totalHeight * inc;\n};\n\n/**\n * Helper function in calculating integral of a function\n * from a to b using simpson quadrature.\n *\n * @param {Function} math function to be evaluated.\n * @param {Number} point to initiate evaluation.\n * @param {Number} point to complete evaluation.\n * @return {Number} evaluation.\n */\nfunction SimpsonDef (func, a, b) {\n  var c = (a + b) / 2;\n  var d = Math.abs(b - a) / 6;\n  return d * (func(a) + 4 * func(c) + func(b));\n}\n\n/**\n * Helper function in calculating integral of a function\n * from a to b using simpson quadrature.  Manages recursive\n * investigation, handling evaluations within an error bound.\n *\n * @param {Function} math function to be evaluated.\n * @param {Number} point to initiate evaluation.\n * @param {Number} point to complete evaluation.\n * @param {Number} total value.\n * @param {Number} Error bound (epsilon).\n * @return {Number} recursive evaluation of left and right side.\n */\nfunction SimpsonRecursive (func, a, b, whole, eps) {\n  var c = a + b;\n  var left = SimpsonDef(func, a, c);\n  var right = SimpsonDef(func, c, b);\n  \n  if (Math.abs(left + right - whole) <= 15 * eps) {\n    return left + right + (left + right - whole) / 15;\n  } else {\n    return SimpsonRecursive(func, a, c, eps / 2, left) + SimpsonRecursive(func, c, b, eps / 2, right);\n  }\n}\n\n/**\n * Evaluate area under a curve using adaptive simpson quadrature.\n *\n * @param {Function} math function to be evaluated.\n * @param {Number} point to initiate evaluation.\n * @param {Number} point to complete evaluation.\n * @param {Number} Optional error bound (epsilon); \n *   global error bound will be used as a fallback.\n * @return {Number} area underneath curve.\n */\ncalculus.adaptiveSimpson = function (func, a, b, eps) {\n  eps = (typeof eps === 'undefined') ? numbers.EPSILON : eps;\n\n  return SimpsonRecursive(func, a, b, SimpsonDef(func, a, b), eps);\n};\n\n/**\n * Calculate limit of a function at a given point. Can approach from\n * left, middle, or right.\n *\n * @param {Function} math function to be evaluated.\n * @param {Number} point to evaluate.\n * @param {String} approach to limit.\n * @return {Number} limit.\n */\ncalculus.limit = function (func, point, approach) {\n  if (approach === 'left') {\n    return func(point - 1e-15);\n  } else if (approach === 'right') {\n    return func(point + 1e-15);\n  } else if (approach === 'middle') {\n    return (calculus.limit(func, point, 'left') + calculus.limit(func, point, 'right')) / 2;\n  } else {\n    throw new Error('Approach not provided');\n  }\n};\n\n/**\n * Calculate Stirling approximation gamma.\n *\n * @param {Number} number to calculate.\n * @return {Number} gamma.\n */\ncalculus.StirlingGamma = function (num) {\n  return Math.sqrt(2 * Math.PI / num) * Math.pow((num / Math.E), num);\n};\n\n/**\n * Calculate Lanczos approximation gamma.\n *\n * @param {Number} number to calculate.\n * @return {Number} gamma.\n */\ncalculus.LanczosGamma = function (num) {\n  var p = [\n    0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n    771.32342877765313, -176.61502916214059, 12.507343278686905,\n    -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7\n  ];\n\n  var i;\n  var g = 7;\n\n  if(num < 0.5) return Math.PI / (Math.sin(Math.PI * num) * calculus.LanczosGamma(1 - num));\n\n  num -= 1;\n  \n  var a = p[0];\n  var t = num + g + 0.5;\n\n  for (i = 1; i < p.length; i++) {\n    a += p[i] / (num + i);\n  }\n\n  return Math.sqrt(2 * Math.PI) * Math.pow(t, num + 0.5) * Math.exp(-t) * a;\n};\n\n\n/**\n * Calculate the integral of f(x1,x2,...) over intervals \n * [a1,b1], [a2,b2], ..., using the montecarlo method:\n * \n * integral of f(x,y) = (1/N)*(b2-a2)*(b1-a1)*sum(f)\n *\n * where N = number of points for f to be evaluated at.\n * The error for this method is about 1/root(N) and will\n * always converge.\n *\n * @param {Function} math function.\n * @param {Number} number of points\n * @param {Array(s)} intervals\n * @return {Number} approximation to integral\n */\ncalculus.MonteCarlo = function(func, N) {\n  //takes an arbitrary number of arguments after N\n  //all of the arguments must be arrays which are intervals\n  if (arguments.length < 2) {\n    throw new Error('Please enter at least one interval.');\n  } else if (N <= 0) {\n    throw new Error('Please use a positive integer for N.');\n  }\n  var L = [];\n  N = Math.ceil(N);\n  for (var i=2; i<arguments.length; i++) {L.push(arguments[i]);}\n  \n  var coeff = L.map(function(l) { //subtract the endpoints\n    return l[1] - l[0];\n  }).reduce(function(a,b) { //multiply each endpoint difference\n    return a*b;\n  }) / N;\n\n  var fvals = numbers.matrix.transpose(L.map(function(l) {\n    //generate an array of arrays, each nested array being N\n    //random values in each interval - N-by-3 array, and then\n    //transpose it to get a 3-by-N array\n    return numbers.statistic.randomSample(l[0],l[1],N);\n  })).map(function(l) {\n    //evaluate func at each set of points\n    return func.apply(null, [ l[0],l[1],l[2] ]);\n  });\n\n  return coeff * fvals.reduce(function(a,b) {return a+b;});\n};","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/complex.js":"/**\n * complex.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar numbers = require('../numbers');\nvar basic = numbers.basic;\n\nvar Complex = function (re, im) {\n  this.re = re;\n  this.im = im;\n  this.r  = this.magnitude();\n  this.t  = this.phase(); // theta = t = arg(z)\n};\n\n/**\n * Add a complex number to this one.\n * \n * @param {Complex} Number to add.\n * @return {Complex} New complex number (sum).\n */\nComplex.prototype.add = function(addend) {\n  return new Complex(this.re + addend.re, this.im + addend.im);\n};\n\n/**\n * Subtract a complex number from this one.\n * \n * @param {Complex} Number to subtract.\n * @return {Complex} New complex number (difference).\n */\nComplex.prototype.subtract = function (subtrahend) {\n  return new Complex(this.re - subtrahend.re, this.im - subtrahend.im);\n};\n\n/**\n * Multiply a complex number with this one.\n * \n * @param {Complex} Number to multiply by.\n * @return {Complex} New complex number (product).\n */\nComplex.prototype.multiply = function (multiplier) {\n  var re = this.re * multiplier.re - this.im * multiplier.im;\n  var im = this.im * multiplier.re + this.re * multiplier.im;\n  \n  return new Complex(re, im);\n};\n\n/**\n * Divide this number with another complex number.\n * \n * @param {Complex} Divisor.\n * @return {Complex} New complex number (quotient).\n */\nComplex.prototype.divide = function (divisor) {\n  var denominator = divisor.re * divisor.re + divisor.im * divisor.im;\n  var re = (this.re * divisor.re + this.im * divisor.im) / denominator;\n  var im = (this.im * divisor.re - this.re * divisor.im) / denominator;\n  \n  return new Complex(re,im);\n};\n\n/**\n * Get the magnitude of this number.\n * \n * @return {Number} Magnitude.\n */\nComplex.prototype.magnitude = function () {\n  return Math.sqrt(this.re * this.re + this.im * this.im);\n};\n\n/**\n * Get the phase of this number.\n * \n * @return {Number} Phase.\n */\nComplex.prototype.phase = function () {\n  return Math.atan2(this.im, this.re);\n};\n\n/**\n * Conjugate the imaginary part\n *\n * @return {Complex} Conjugated number\n */\nComplex.prototype.conjugate = function () {\n  return new Complex(this.re, -1 * this.im);\n};\n\n/**\n * Raises this complex number to the nth power.\n *\n * @param {number} power to raise this complex number to.\n * @return {Complex} the nth power of this complex number.\n */\nComplex.prototype.pow = function(n) {\n  var constant = Math.pow(this.magnitude(), n);\n\n  return new Complex(constant * Math.cos(n * this.phase()), constant * Math.sin(n * this.phase()));\n};\n\n/**\n * Raises this complex number to given complex power.\n *\n * @param complexN the complex number to raise this complex number to.\n * @return {Complex} this complex number raised to the given complex number.\n */\nComplex.prototype.complexPow = function(complexN) {\n  var realSqPlusImSq =  Math.pow(this.re, 2) + Math.pow(this.im, 2);\n  var multiplier = Math.pow(realSqPlusImSq, complexN.re / 2) * Math.pow(Math.E, -complexN.im * this.phase());\n  var theta = complexN.re * this.phase() + 0.5 * complexN.im * Math.log(realSqPlusImSq);\n\n  return new Complex(multiplier * Math.cos(theta), multiplier * Math.sin(theta));\n};\n\n/**\n * Find all the nth roots of this complex number.\n *\n * @param {Number} root of this complex number to take.\n * @return {Array} an array of size n with the roots of this complex number.\n */\nComplex.prototype.roots = function(n) {\n  var result = new Array(n);\n\n  for(var i = 0; i < n; i++) {\n    var theta = (this.phase() + 2*Math.PI*i) / n;\n    var radiusConstant = Math.pow(this.magnitude(), 1 / n);\n\n    result[i] = (new Complex(radiusConstant * Math.cos(theta), radiusConstant * Math.sin(theta)));\n  }\n\n  return result;\n};\n\n\n/**\n * Returns the sine of this complex number.\n *\n * @return {Complex} the sine of this complex number.\n */\nComplex.prototype.sin = function() {\n  var E = new Complex(Math.E, 0);\n  var i = new Complex(0, 1);\n  var negativeI = new Complex(0, -1);\n  var numerator = E.complexPow(i.multiply(this)).subtract(E.complexPow(negativeI.multiply(this)));\n\n  return numerator.divide(new Complex(0, 2));\n};\n\n/**\n * Returns the cosine of this complex number.\n *\n * @return {Complex} the cosine of this complex number.\n */\nComplex.prototype.cos = function() {\n  var E = new Complex(Math.E, 0);\n  var i = new Complex(0, 1);\n  var negativeI = new Complex(0, -1);\n  var numerator = E.complexPow(i.multiply(this)).add(E.complexPow(negativeI.multiply(this)));\n\n  return numerator.divide(new Complex(2, 0));\n};\n\n/**\n * Returns the tangent of this complex number.\n *\n * @return {Complex} the tangent of this complex number.\n */\nComplex.prototype.tan = function() {\n  return this.sin().divide(this.cos());\n};\n\n/**\n * Checks for equality between this complex number and another\n * within a given range defined by epsilon.\n *\n * @param {Complex} complex number to check this number against.\n * @param {Number} epsilon\n * @return {boolean} true if equal within epsilon, false otherwise\n */\nComplex.prototype.equals = function(complex, epsilon) {\n  return basic.numbersEqual(this.re, complex.re, epsilon) &&\n         basic.numbersEqual(this.im, complex.im, epsilon);\n};\n\nmodule.exports = Complex;\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/dsp.js":"/**\n * dsp.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar numbers = require('../numbers');\nvar Complex = numbers.complex;\nvar dsp = exports;\n\n/**\n * Returns an array composed of elements from arr, starting at index start\n * and counting by step.\n * \n * @param {Array} Input array.\n * @param {Number} Starting array index.\n * @param {Number} Step size.\n * @return {Array} Resulting sub-array.\n */\ndsp.segment = function (arr, start, step) {\n  var result = [];\n  \n  for (var i = start; i < arr.length; i += step) {\n    result.push(arr[i]);\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of complex numbers representing the frequency spectrum\n * of real valued time domain sequence x. (x.length must be integer power of 2)\n * Inspired by http://rosettacode.org/wiki/Fast_Fourier_transform#Python\n * \n * @param {Array} Real-valued series input, eg. time-series.\n * @return {Array} Array of complex numbers representing input signal in Fourier domain.\n */\ndsp.fft = function (x) {\n  var N = x.length;\n  \n  if (N <= 1) {\n    return [new Complex(x[0], 0)];\n  }  \n  \n  if (Math.log(N) / Math.LN2 % 1 !== 0) {\n    throw new Error ('Array length must be integer power of 2');\n  }\n  \n  var even = dsp.fft(dsp.segment(x, 0, 2));\n  var odd = dsp.fft(dsp.segment(x, 1, 2));\n  var res = [], Nby2 = N / 2;\n  \n  for (var k = 0; k < N; k++) {\n    var tmpPhase = -2 * Math.PI * k / N;\n    var phasor = new Complex(Math.cos(tmpPhase), Math.sin(tmpPhase));\n    if (k < Nby2) {\n      res[k] = even[k].add(phasor.multiply(odd[k]));\n    } else {\n      res[k] = even[k - Nby2].subtract(phasor.multiply(odd[k - Nby2]));\n    }\n  }\n  \n  return res;\n};\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/matrix.js":"/**\n * matrix.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar matrix = exports;\n\nvar ERROR_MATRIX_NOT_SQUARE = 'Matrix must be square.',\n    ERROR_VECTOR_NOT_2D = 'Only two dimensional operations are supported at this time.';\n\n/**\n * Check to see if a point is 2D. Used in all 2D vector functions.\n * Throw error if it's not.\n *\n * @param {Array} point in question.\n * @return {undefined} nothing is returned.\n */\nmatrix._check2DVector = function(point) {\n  if (point.length !== 2) {\n    throw new Error(ERROR_VECTOR_NOT_2D);\n  }\n};\n\n/**\n * Return a deep copy of the input matrix.\n *\n * @param {Array} matrix to copy.\n * @return {Array} copied matrix.\n */\nmatrix.deepCopy = function(arr) {\n  if (!Array.isArray(arr)) {\n    throw new Error('Input must be a matrix.');\n  } else if (arr[0][0] === undefined) {\n    throw new Error('Input cannot be a vector.');\n  }\n  var result = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    result[i] = arr[i].slice();\n  }\n  \n  return result;\n};\n\n/**\n * Return true if matrix is square, false otherwise.\n *\n * @param {Array} arr\n * @return {Boolean} \n */\nmatrix.isSquare = function(arr) {\n  if (!Array.isArray(arr)) {\n    throw new Error('Input must be a matrix.');\n  } else if (arr[0][0] === undefined) {\n    throw new Error('Input cannot be a vector.');\n  }\n  var rows = arr.length;\n\n  for (var i = 0; i < rows; i++) {\n    if (arr[i].length !== rows) return false;\n  }\n\n  return true;\n};\n\n/**\n * Add two matrices together.  Matrices must be of same dimension.\n *\n * @param {Array} matrix A.\n * @param {Array} matrix B.\n * @return {Array} summed matrix.\n */\nmatrix.addition = function (arrA, arrB) {\n  if (arrA.length !== arrB.length || arrA[0].length !== arrB[0].length) {\n    throw new Error('Matrix mismatch');\n  }\n\n  var result = new Array(arrA.length),\n      i;\n  \n  if (!arrA[0].length) {\n    // The arrays are vectors.\n    for (i = 0; i < arrA.length; i++) {\n      result[i] = arrA[i] + arrB[i];\n    }\n  } else {\n    for (i = 0; i < arrA.length; i++) {\n        result[i] = new Array(arrA[i].length);\n      \n        for (var j = 0; j < arrA[i].length; j++) {\n          result[i][j] = arrA[i][j] + arrB[i][j];\n        }\n    }\n  }\n\n  return result;\n};\n\n/**\n * Subtract one matrix from another (A - B).  Matrices must be of same dimension.\n *\n * @param {Array} matrix A.\n * @param {Array} matrix B.\n * @return {Array} subtracted matrix.\n */\nmatrix.subtraction = function (arrA, arrB) {\n  if (arrA.length !== arrB.length || arrA[0].length !== arrB[0].length) {\n    throw new Error(\"Matrix mismatch\");\n  }\n\n  var result = new Array(arrA.length),\n      i;\n  \n  if (!arrA[0].length) {\n    // The arrays are vectors.\n    for (i = 0; i < arrA.length; i++) {\n      result[i] = arrA[i] - arrB[i];\n    }\n  } else {\n    for (i = 0; i < arrA.length; i++) {\n        result[i] = new Array(arrA[i].length);\n      \n        for (var j = 0; j < arrA[i].length; j++) {\n          result[i][j] = arrA[i][j] - arrB[i][j];\n        }\n    }\n  }\n\n  return result;\n};\n\n/**\n * Scalar multiplication on an matrix.\n *\n * @param {Array} matrix.\n * @param {Number} scalar.\n * @return {Array} updated matrix.\n */\nmatrix.scalar = function (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = 0; j < arr[i].length; j++) {\n      arr[i][j] = val * arr[i][j];\n    }\n  }\n\n  return arr;\n};\n\n/**\n * Transpose a matrix.\n *\n * @param {Array} matrix.\n * @return {Array} transposed matrix.\n */\nmatrix.transpose = function (arr) {\n  var result = new Array(arr[0].length);\n  \n  for (var i = 0; i < arr[0].length; i++) {\n    result[i] = new Array(arr.length);\n    \n    for (var j = 0; j < arr.length; j++) {\n      result[i][j] = arr[j][i];\n    }\n  }\n\n  return result;\n};\n\n/**\n * Create an identity matrix of dimension n x n.\n *\n * @param {Number} dimension of the identity array to be returned.\n * @return {Array} n x n identity matrix.\n */\nmatrix.identity = function (n) {\n  var result = new Array(n);\n  \n  for (var i = 0; i < n ; i++) {\n    result[i] = new Array(n);\n    for (var j = 0; j < n; j++) {\n      result[i][j] = (i === j) ? 1 : 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Evaluate dot product of two vectors.  Vectors must be of same length.\n *\n * @param {Array} vector.\n * @param {Array} vector.\n * @return {Array} dot product.\n */\nmatrix.dotproduct = function (vectorA, vectorB) {\n  if (vectorA.length !== vectorB.length) {\n    throw new Error(\"Vector mismatch\");\n  }\n\n  var result = 0;\n  for (var i = 0; i < vectorA.length; i++) {\n    result += vectorA[i] * vectorB[i];\n  }\n  return result;\n};\n\n/**\n * Multiply two matrices. They must abide by standard matching.\n *\n * e.g. A x B = (m x n) x (n x m), where n, m are integers who define\n * the dimensions of matrices A, B.\n *\n * @param {Array} matrix.\n * @param {Array} matrix.\n * @return {Array} result of multiplied matrices.\n */\nmatrix.multiply = function (arrA, arrB) {\n  if (arrA[0].length !== arrB.length) {\n    throw new Error(\"Matrix mismatch\");\n  }\n\n  var result = new Array(arrA.length);\n  \n  for (var x = 0; x < arrA.length; x++) {\n    result[x] = new Array(arrB[0].length);\n  }\n\n  var arrB_T = matrix.transpose(arrB);\n  \n  for (var i = 0; i < result.length; i++) {\n    for (var j = 0; j < result[i].length; j++) {\n      result[i][j] = matrix.dotproduct(arrA[i],arrB_T[j]);\n    }\n  }\n  return result;\n};\n\n/**\n * Evaluate determinate of matrix.  Expect speed\n * degradation for matrices over 4x4. \n *\n * @param {Array} matrix.\n * @return {Number} determinant.\n */\nmatrix.determinant = function (m) {\n  var numRow = m.length;\n  var numCol = m[0].length;\n  var det = 0;\n  var row, col;\n  var diagLeft, diagRight;\n\n  if (!matrix.isSquare(m)) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  if (numRow === 1) {\n    return m[0][0];\n  } else if (numRow === 2) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n  }\n\n  for (col = 0; col < numCol; col++) {\n    diagLeft = m[0][col];\n    diagRight = m[0][col];\n\n    for( row=1; row < numRow; row++ ) {\n      diagRight *= m[row][(((col + row) % numCol) + numCol) % numCol];\n      diagLeft *= m[row][(((col - row) % numCol) + numCol) % numCol];\n    }\n\n    det += diagRight - diagLeft;\n  }\n\n  return det;\n};\n\n/**\n * Returns a LUP decomposition of the given matrix such that:\n *\n * A*P = L*U\n *\n * Where\n * A is the input matrix\n * P is a pivot matrix\n * L is a lower triangular matrix\n * U is a upper triangular matrix\n *\n * This method returns an array of three matrices such that:\n *\n * matrix.luDecomposition(array) = [L, U, P]\n *\n * @param {Array} arr\n * @return {Array} array of matrices [L, U, P]\n */\nmatrix.lupDecomposition = function(arr) {\n  if (!matrix.isSquare(arr)) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  var size = arr.length;\n\n  var LU = matrix.deepCopy(arr);\n  var P = matrix.transpose(matrix.identity(size));\n  var currentRow;\n  var currentColumn = new Array(size);\n\n  this.getL = function(a) {\n    var m = a[0].length;\n    var L = matrix.identity(m);\n    \n    for (var i = 0; i < m; i++) {\n      for (var j = 0; j < m; j++) {\n        if (i > j) {\n          L[i][j] = a[i][j];\n        }\n      }\n    }\n    \n    return L;\n  };\n\n  this.getU = function(a) {\n    var m = a[0].length;\n    var U = matrix.identity(m);\n    \n    for (var i = 0; i < m; i++) {\n      for (var j = 0; j < m; j++) {\n        if (i <= j) {\n          U[i][j] = a[i][j];\n        }\n      }\n    }\n    \n    return U;\n  };\n\n  for (var j = 0; j < size; j++) {\n    var i;\n    for (i = 0; i < size; i++) {\n      currentColumn[i] = LU[i][j];\n    }\n\n    for (i = 0; i < size; i++) {\n      currentRow = LU[i];\n\n      var minIndex = Math.min(i,j);\n      var s = 0;\n    \n      for (var k = 0; k < minIndex; k++) {\n        s += currentRow[k]*currentColumn[k];\n      }\n\n      currentRow[j] = currentColumn[i] -= s;\n    }\n\n    //Find pivot\n    var pivot = j;\n    for (i = j + 1; i < size; i++) {\n      if (Math.abs(currentColumn[i]) > Math.abs(currentColumn[pivot])) {\n        pivot = i;\n      }\n    }\n    \n    if (pivot != j) {\n      LU = matrix.rowSwitch(LU, pivot, j);\n      P = matrix.rowSwitch(P, pivot, j);\n    }\n\n    if (j < size && LU[j][j] !== 0) {\n      for (i = j + 1; i < size; i++) {\n        LU[i][j] /= LU[j][j];\n      }\n    }\n  }\n  \n  return [this.getL(LU), this.getU(LU), P];\n};\n\n/**\n * Rotate a two dimensional vector by degree.\n *\n * @param {Array} point.\n * @param {Number} degree.\n * @param {String} direction - clockwise or counterclockwise.\n * @return {Array} vector.\n */\nmatrix.rotate = function (point, degree, direction) {\n  matrix._check2DVector(point);\n\n  var negate = direction === 'clockwise' ? -1 : 1;\n  var radians = degree * (Math.PI / 180);\n\n  var transformation = [\n    [Math.cos(radians), -1 * negate * Math.sin(radians)],\n    [negate * Math.sin(radians), Math.cos(radians)]\n  ];\n\n  return matrix.multiply(transformation, point);\n};\n\n/**\n * Scale a two dimensional vector by scale factor x and scale factor y.\n *\n * @param {Array} point.\n * @param {Number} sx.\n * @param {Number} sy.\n * @return {Array} vector.\n */\nmatrix.scale = function (point, sx, sy) {\n  matrix._check2DVector(point);\n\n  var transformation = [\n    [sx, 0],\n    [0, sy]\n  ];\n\n  return matrix.multiply(transformation, point);\n};\n\n/**\n * Shear a two dimensional vector by shear factor k.\n *\n * @param {Array} point.\n * @param {Number} k.\n * @param {String} direction - xaxis or yaxis.\n * @return {Array} vector.\n */\nmatrix.shear = function (point, k, direction) {\n  matrix._check2DVector(point);\n\n  var xplaceholder = direction === 'xaxis' ? k : 0;\n  var yplaceholder = direction === 'yaxis' ? k : 0;\n\n  var transformation = [\n    [1, xplaceholder],\n    [yplaceholder, 1]\n  ];\n\n  return matrix.multiply(transformation, point);\n};\n\n/**\n * Perform an affine transformation on the given vector.\n *\n * @param {Array} point.\n * @param {Number} tx.\n * @param {Number} ty.\n * @return {Array} vector.\n */\nmatrix.affine = function (point, tx, ty) {\n  matrix._check2DVector(point);\n  var transformation = [\n    [1, 0, tx],\n    [0, 1, ty],\n    [0, 0, 1 ]\n  ];\n\n  var newpoint = [\n    [point[0][0]],\n    [point[1][0]],\n    [1]\n  ];\n\n  var transformed = matrix.multiply(transformation, newpoint);\n  \n  return [\n    [transformed[0][0]],\n    [transformed[1][0]]\n  ];\n};\n\n/**\n * Scales a row of a matrix by a factor and returns the updated matrix. \n * Used in row reduction functions.\n * \n * @param {Array} matrix.\n * @param {Number} row.\n * @param {Number} scale.\n */\nmatrix.rowScale = function (m, row, scale) {\n  var result = new Array(m.length);\n    \n  for (var i = 0; i < m.length; i++) {\n    result[i] = new Array(m[i].length);\n  \n    for (var j = 0; j < m[i].length; j++) {\n      if (i === row) {\n        result[i][j] = scale * m[i][j]; \n      } else {\n        result[i][j] = m[i][j];\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n * Swaps two rows of a matrix  and returns the updated matrix. \n * Used in row reduction functions.\n * \n * @param {Array} matrix.\n * @param {Number} row1.\n * @param {Number} row2.\n */\nmatrix.rowSwitch = function (m, row1, row2) {\n  var result = new Array(m.length);\n  \n  for (var i = 0; i < m.length; i++) {\n    result[i] = new Array(m[i].length);\n  \n    for (var j = 0; j < m[i].length; j++) {\n      if (i === row1) {\n        result[i][j] = m[row2][j]; \n      } else if (i === row2) {\n        result[i][j] = m[row1][j];\n      } else {\n        result[i][j] = m[i][j];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Adds a multiple of one row to another row\n * in a matrix and returns the updated matrix. \n * Used in row reduction functions.\n * \n * @param {Array} matrix.\n * @param {Number} row1.\n * @param {Number} row2.\n */\nmatrix.rowAddMultiple = function (m, from, to, scale){\n  var result = new Array(m.length);\n  \n  for (var i = 0; i < m.length; i++) {\n    result[i] = new Array(m[i].length);\n  \n    for (var j = 0; j < m[i].length; j++) {\n      if (i === to) {\n        result[to][j] = m[to][j] + scale * m[from][j];\n      } else {\n        result[i][j] = m[i][j];\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n * Gauss-Jordan Elimination\n *\n * @param {Array} matrix.\n * @param {Number} epsilon.\n * @return {Array} RREF matrix.\n */\nmatrix.GaussJordanEliminate = function(m, epsilon) {\n  // Translated from:\n  // http://elonen.iki.fi/code/misc-notes/python-gaussj/index.html\n  var eps = (typeof epsilon == 'undefined') ? 1e-10 : epsilon;\n\n  var h = m.length;\n  var w = m[0].length;\n  var y = -1;\n  var y2, x, c;\n\n  while (++y < h) {\n    // Pivot.\n    var maxrow = y;\n    y2 = y;\n    while (++y2 < h) {\n      if(Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n        maxrow = y2;\n    }\n    var tmp = m[y];\n    m[y] = m[maxrow];\n    m[maxrow] = tmp;\n\n    // Singular\n    if(Math.abs(m[y][y]) <= eps) {\n      return m;\n    }\n\n    // Eliminate column\n    y2 = y;\n    while (++y2 < h) {\n      c = m[y2][y] / m[y][y];\n      x = y - 1;\n      while (++x < w) {\n        m[y2][x] -= m[y][x] * c;\n      }\n    }\n  }\n\n  // Backsubstitute.\n  y = h;\n  while (--y >= 0) {\n    c = m[y][y];\n    y2 = -1;\n    while (++y2 < y) {\n      x = w;\n      while (--x >= y) {\n        m[y2][x] -=  m[y][x] * m[y2][y] / c;\n      }\n    }\n    m[y][y] /= c;\n\n    // Normalize row\n    x = h - 1;\n    while (++x < w) {\n      m[y][x] /= c;\n    }\n  }\n\n  return m;\n};\n\n/**\n * Alias to Gauss-Jordan Elimination\n *\n * @param {Array} matrix.\n * @param {Number} epsilon.\n * @return {Array} RREF matrix.\n */\nmatrix.rowReduce = function(m, epsilon) {\n  return matrix.GaussJordanEliminate(m, epsilon);\n};\n\n/**\n * nxn matrix inversion\n *\n * @param {Array} matrix.\n * @return {Array} inverted matrix.\n */\nmatrix.inverse = function(m) {\n  if (!matrix.isSquare(m)) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  var n = m.length,\n      identity = matrix.identity(n),\n      i;\n\n  // AI\n  for(i=0; i<n; i++) {\n    m[i] = m[i].concat(identity[i]);\n  }\n\n  // inv(IA)\n  m = matrix.GaussJordanEliminate(m);\n\n  // inv(A)\n  for(i=0; i<n; i++) {\n    m[i] = m[i].slice(n);\n  }\n\n  return m;\n};\n\n/**\n * Get a column of a matrix as a vector.\n *\n * @param {Array} matrix\n * @param {Int} column number\n * @return {Array} column\n */\nmatrix.getCol = function(M, n) {\n  var result = new Array(M.length);\n  if (n < 0) {\n    throw new Error('The specified column must be a positive integer.');\n  } else if (n >= M[0].length) {\n    throw new Error('The specified column must be between 0 and the number of columns - 1.');\n  }\n  for (var i=0; i<M.length; i++) {\n    result[i] = M[i][n];\n  }\n  return result;\n};\n\n/**\n * Reorder the rows of a matrix based off an array of numbers.\n *\n * @param {Array} matrix\n * @param {Array} desired re-ordering\n * @return {Array} reordered matrix\n */\nmatrix.reorderRows = function(M, L) {\n  var result = [];\n  if (L === undefined) {\n    throw new Error('A reordering array must be entered.');\n  } else if (L.length !== M.length) {\n    throw new Error ('The reordered matrix must have the same number of rows as the original matrix.');\n  }\n  for (var i=0; i<L.length; i++) {\n    if (L[i] < 0) {\n      throw new Error('The desired order of the rows must be positive integers.');\n    } else if (L[i] >= L.length) {\n      throw new Error('The desired order of the rows must start at 0 and end at the number of rows - 1.');\n    } else {  \n      result.push(M[L[i]]);\n    }\n  }\n  return result;\n};\n\n/**\n * Reorder the columns of a matrix based off an array of numbers.\n *\n * @param {Array} matrix\n * @param {Array} desired re-ordering\n * @return {Array} reordered matrix\n */\nmatrix.reorderCols = function(M, L) {\n  var result = [];\n  if (L === undefined) {\n    throw new Error('Please enter a desired reordering array.');\n  } else if (L.length !== M[0].length) {\n    throw new Error('The reordered matrix must have the same number of columns as the original matrix.');\n  }\n  for (var i=0; i<L.length; i++) {\n    if (L[i] < 0) {\n      throw new Error('The desired order of the columns must be positive integers.');\n    } else if (L[i] >= L.length) {\n      throw new Error('The desired order of the columns must start at 0 and end at the number of columns - 1.');\n    } else {\n      result.push(matrix.getCol(M, L[i]) );\n    }\n  }\n  return matrix.transpose(result);\n};\n\n/**\n * Reverse the rows of a matrix.\n *\n * @param {Array} matrix\n * @return {Array} reversed matrix\n */\nmatrix.reverseRows = function(M) {\n    var L = [];\n    for (var i=M.length-1; i>-1; i--) {\n        L.push(i);\n    }\n    return matrix.reorderRows(M,L);\n};\n\n/**\n * Reverse the columns of a matrix.\n *\n * @param {Array} matrix\n * @return {Array} reversed matrix\n */\nmatrix.reverseCols = function(M) {\n    var L = [];\n    for (var i=M.length-1; i>-1; i--) {\n        L.push(i);\n    }\n    return matrix.reorderCols(M,L);\n};\n\n/**\n * Create a n x m matrix of zeros.\n *\n * @param {Int} number of rows\n * @param {Int} number of columns\n * @return {Array} matrix\n */\nmatrix.zeros = function(n,m) {\n  var M = new Array(n);\n  if (n < 1 || m < 1) {\n    throw new Error('The matrix dimensions must be positive integers.');\n  }\n  n = Math.ceil(n);\n  m = Math.ceil(m);\n  for (var i=0; i<n; i++) {\n    var empty = new Array(m);\n    for (var j=0; j<m; j++) {\n      empty[j] = 0;\n    }\n    M[i] = empty;\n  }\n  return M;\n};\n\n/**\n * Create a zigzag matrix. point represents the starting corner,\n * dir represents which direction to begin moving in. There are\n * 8 possible permutations for this. Rounds dimension upwards.\n *\n * @param {Int} size of (square) matrix\n * @param {String} corner (TL,TR,BL,BR)\n * @param {String} direction (V,H)\n * @return {Array} zigzag matrix.\n */\nmatrix.zigzag = function(n, point, dir) {\n  if (n <= 1) {\n    throw new Error('Matrix size must be at least 2x2.');\n  }\n  n = Math.ceil(n);\n  var mat = matrix.zeros(n,n);\n\n  //create one kind of permutation - all other permutations can be \n  //created from this particular permutation through transformations\n  var BRH = function(M) { //starting at bottom right, moving horizontally\n    var jump = false,\n        tl = n*n, \n        br = 1, \n        inc = 1,\n        row, col, val, i, j;\n    M[0][0] = tl;\n    M[n-1][n-1] = br;\n\n    for (i=1; i<n; i++) {\n      //generate top/bottom row\n      if (jump) {\n        tl -= 4*inc;\n        br += 4*inc;\n        inc++;\n      } else {\n        tl--;\n        br++;\n      }\n\n      M[0][i] = tl;\n      M[n-1][n-1-i] = br;\n      jump = !jump;\n    }\n\n    var dec = true;\n    for (i=1; i<n; i++) {\n      //iterate diagonally from top row\n      row = 0;\n      col = i; \n      val = M[row][col];\n\n      for (j=1; j<i+1;j++) {\n        if (dec) {\n          val -= 1;\n        } else {\n          val += 1;\n        }\n        row++;\n        col--;\n        M[row][col] = val;\n      }\n        dec = !dec;\n    }\n\n    if (n%2 === 0) {\n      dec = true;\n    } else {\n      dec = false;\n    }\n    for (i=1; i<n-1; i++) {\n      //iterate diagonally from bottom row\n      row = n-1;\n      col = i;\n      val = M[row][col];\n\n      for (j=1; j<n-i; j++) {\n        if (dec) {\n          val--;\n        } else {\n          val++;\n        }\n        row--;\n        col++;\n        M[row][col] = val;\n      }\n      dec = !dec;\n    }\n    return M;\n  };\n\n  var BRV = function(M) {//starting at bottom right, moving vertically\n    return matrix.transpose(BRH(M));\n  };\n\n  var BLH = function(M) {//starting at bottom left, moving horizontally\n    return matrix.reverseCols(BRH(M));\n  };\n\n  var BLV = function(M) {//starting at bottom left, moving vertically\n    return matrix.reverseRows(TLV(BLH(M)));\n  };\n\n  var TRH = function(M) {//starting at top right, moving horizontally\n    return matrix.reverseRows(BRH(M));\n  };\n\n  var TRV = function(M) {//starting at top right, moving vertically\n    return matrix.reverseRows(BRV(M));\n  };\n\n  var TLH = function(M) {//starting at top left, moving horizontally\n    return matrix.reverseCols(matrix.reverseRows(BRH(M)));\n  };\n\n  var TLV = function(M) {//starting at top left, moving vertically\n    return matrix.transpose(TLH(M));\n  };\n\n  if ((point === 'BR') && (dir === 'H')) {return (BRH(mat));}\n  else if ((point === 'BR') && (dir === 'V')) {return (BRV(mat));}\n  else if ((point === 'BL') && (dir === 'H')) {return (BLH(mat));}\n  else if ((point === 'BL') && (dir === 'V')) {return (BLV(mat));}\n  else if ((point === 'TR') && (dir === 'H')) {return (TRH(mat));}\n  else if ((point === 'TR') && (dir === 'V')) {return (TRV(mat));}\n  else if ((point === 'TL') && (dir === 'H')) {return (TLH(mat));}\n  else if ((point === 'TL') && (dir === 'V')) {return (TLV(mat));}\n  else {throw new Error('Enter the direction (V,H) and corner (BR,BL,TR,TL) correctly.');}\n};\n\n/**\n * Calculate the p-norm of a vector. Specific cases include:\n *   - Infinity (largest absolute entry)\n *   - -Infinity (smallest absolute entry)\n *\n * @param {Array} vector\n * @param {Number} the value of p (norm order)\n * @return {Number} the p-norm of v\n */\nmatrix.vectorNorm = function(v,p) {\n  // calculate the p'th norm of a vector v\n  if (!(Array.isArray(v)) || (v.length === 0)) {\n    throw new Error('Vector must be an array of at least length 1.');\n  } else if ((typeof p !== 'undefined') && (typeof p !== 'number')) {\n    throw new Error('Norm order must be a number.');\n  }\n\n  p = (typeof p === 'undefined') ? 2 : p;\n  var n = v.length,\n    ans = 0,\n    term, i;\n\n  switch (p) {\n\n    case Infinity:\n      for (i=0; i<n; i++) {\n        term = Math.abs(v[i]);\n        if (term > ans) {\n          ans = term;\n        }\n      }\n      break;\n\n    case -Infinity:\n      ans = Infinity;\n      for (i=0; i<n; i++) {\n        term = Math.abs(v[i]);\n        if (term < ans) {\n          ans = term;\n        }\n      }\n      break;\n\n    default:\n      for (i=0; i<n; i++) {\n        ans += Math.pow(Math.abs(v[i]), p);\n      }\n      ans = Math.pow(ans, 1/p);\n      break;\n  }\n\n  return ans;\n};\n\n/**\n * Calculate the p-norm of a matrix. Specific cases include:\n *   - Infinity (largest absolute row)\n *   - -Infinity (smallest absolute row)\n *   - 1 (largest absolute column)\n *   - -1 (smallest absolute column)\n *   - 2 (largest singular value)\n *   - -2 (smallest singular value)\n *   - null (Frobenius norm)\n *\n * @param {Array} vector\n * @param {Number} the value of p (norm order)\n * @return {Number} the p-norm of M\n */\nmatrix.matrixNorm = function(M,p) {\n  if (!(Array.isArray(M)) || (M.length === 0) || !Array.isArray(M[0])) {\n    throw new Error('Matrix must be an array of at least length 1.');\n  } else if ((typeof p !== 'undefined') && (typeof p !== 'number') && (p !== null)) {\n    throw new Error('Norm order must be a number or null.');\n  }\n\n  p = (typeof p === 'undefined') ? null : p;\n  var m = M.length, //number of rows\n    n = M[0].length, //number of cols\n    ans = 0,\n    term, i, j;\n\n  switch (p) {\n\n    // the largest value when absolute-ing and summing each row\n    case Infinity:\n      for (i=0; i<m; i++) {\n        term = 0;\n\n        for (j=0; j<n; j++) {\n          term += Math.abs(M[i][j]);\n        }\n\n        if (term > ans) {\n          ans = term;\n        }\n      }\n      break;\n\n    // the smallest value when absolute-ing and summing each row\n    case -Infinity:\n      ans = Infinity;\n      for (i=0; i<m; i++) {\n        term = 0;\n\n        for (j=0; j<n; j++) {\n          term += Math.abs(M[i][j]);\n        }\n\n        if (term < ans) {\n          ans = term;\n        }\n      }\n      break;\n\n    // the largest value when absolute-ing and summing each column\n    case 1:\n      for (i=0; i<n; i++) {\n        term = 0;\n\n        for (j=0; j<m; j++) {\n          term += Math.abs(M[j][i]);\n        }\n\n        if (term > ans) {\n          ans = term;\n        }\n      }\n      break;\n\n    // the smallest value when absolute-ing and summing each column\n    case -1:\n      ans = Infinity;\n      for (i=0; i<n; i++) {\n        term = 0;\n\n        for (j=0; j<m; j++) {\n          term += Math.abs(M[j][i]);\n        }\n\n        if (term < ans) {\n          ans = term;\n        }\n      }\n      break;\n\n    // the Frobenius norm\n    case null:\n      for (i=0; i<m; i++) {\n        for (j=0; j<n; j++) {\n          ans += Math.pow(M[i][j], 2);\n        }\n      }\n      ans = Math.pow(ans, 0.5);\n      break;\n\n    // largest singular value\n    case 2:\n      throw new Error(\"Singular values are not yet supported in numbers.js.\");\n\n    // smallest singular value\n    case -2:\n      throw new Error(\"Singular values are not yet supported in numbers.js.\");\n\n    // entry-wise norm; analogous to that of the entry-wise vector norm.\n    default:\n      for (i=0; i<m; i++) {\n        for (j=0; j<n; j++) {\n          ans += Math.pow(Math.abs(M[i][j]), p);\n        }\n      }\n      ans = Math.pow(ans, 1/p);\n\n  }\n\n  return ans;\n};\n\n/**\n * Determines if a matrix has an upper bandwidth of q.\n *\n * @param {Array} matrix\n * @param {Number} upper bandwidth\n * @return {Boolean} true if upper bandwidth is q; false otherwise\n */\nmatrix.isUpperBand = function(M,q) {\n  if (!Array.isArray(M) || !Array.isArray(M[0]) || M.length < 2) {\n    throw new Error('Matrix must be an array of at least dimension 2.');\n  } else if (typeof q !== 'number' || q < 0 || (q%1) !== 0) {\n    throw new Error('Upper bandwidth must be a nonzero integer.');\n  }\n  var result = true,\n    n = M[0].length,\n    cnt = 0;\n\n  for (var i=q+1; i<n; i++) {\n    if (M[cnt][i] !== 0) {\n      result = false;\n      break;\n    }\n    cnt++;\n  }\n  return result;\n};\n\n/**\n * Determines if a matrix has an lower bandwidth of p.\n *\n * @param {Array} matrix\n * @param {Number} lower bandwidth\n * @return {Boolean} true if lower bandwidth is p; false otherwise\n */\nmatrix.isLowerBand = function(M,p) {\n  if (!Array.isArray(M) || !Array.isArray(M[0]) || M.length < 2) {\n    throw new Error('Matrix must be an array of at least dimension 2.');\n  } else if (typeof p !== 'number' || p < 0 || (p%1) !== 0) {\n    throw new Error('Lower bandwidth must be a nonzero integer.');\n  }\n  var result = true,\n    m = M.length,\n    cnt = 0;\n\n  for (var i=p+1; i<m; i++) {\n    if (M[i][cnt] !== 0) {\n      result = false;\n      break;\n    }\n    cnt++;\n  }\n  return result;\n};\n\n/**\n * Add all of the elements in an array together except for the i'th one.\n * This is a helper function for determining diagonal dominance, and it \n * should be noted that each element is passed to Math.abs() beforehand.\n *\n * @param {Array} array\n * @param {Int} index of element to ignore.\n * @return {Number} sum.\n */\nsumNondiagonalElements = function(arr, i) {\n  var sum = 0,\n      j;\n\n  for (j=0; j<i; j++) {\n    sum += Math.abs(arr[j]);\n  }\n  for (j=i+1; j<arr.length; j++) {\n    sum += Math.abs(arr[j]);\n  }\n  return sum;\n};\n\n/**\n * Determines if a matrix is (weak) row diagonally-dominant.\n *\n * @param {Array} matrix\n * @return {Boolean} true if so, false otherwise.\n */\nmatrix.isRowDD = function(M) {\n  var n = M.length;\n  if (!matrix.isSquare(M)) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  for (var i=0; i<n; i++) {\n    var row = M[i],\n        diag = row[i],\n        sum = sumNondiagonalElements(row, i);\n\n    if (Math.abs(diag) < sum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Determines if a matrix is strictly row diagonally-dominant.\n *\n * @param {Array} matrix\n * @return {Boolean} true if so, false otherwise.\n */\nmatrix.isStrictlyRowDD = function(M) {\n  if (!matrix.isSquare(M)) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  var n = M.length;\n\n  for (var i=0; i<n; i++) {\n    var row = M[i],\n        diag = row[i],\n        sum = sumNondiagonalElements(row, i);\n\n    if (Math.abs(diag) <= sum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Determines if a matrix is (weak) column diagonally-dominant.\n *\n * @param {Array} matrix\n * @return {Boolean} true if so, false otherwise.\n */\nmatrix.isColumnDD = function(M) {\n  if (!matrix.isSquare) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  var n = M.length;\n\n  for (var i=0; i<n; i++) {\n    var col = matrix.getCol(M,i),\n        diag = col[i],\n        sum = sumNondiagonalElements(col, i);\n\n    if (Math.abs(diag) < sum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Determines if a matrix is strictly column diagonally-dominant.\n *\n * @param {Array} matrix\n * @return {Boolean} true if so, false otherwise.\n */\nmatrix.isStrictlyColumnDD = function(M) {\n  if (!matrix.isSquare(M)) {\n    throw new Error(ERROR_MATRIX_NOT_SQUARE);\n  }\n\n  var n = M.length;\n\n  for (var i=0; i<n; i++) {\n    var col = matrix.getCol(M,i),\n        diag = col[i],\n        sum = sumNondiagonalElements(col, i);\n\n    if (Math.abs(diag) <= sum) {\n      return false;\n    }\n  }\n  return true;\n};","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/prime.js":"/**\n * prime.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar basic = require('./basic');\nvar prime = exports;\n\n/**\n * Determine if number is prime.  \n * Adopted from http://www.javascripter.net/faq/numberisprime.htm\n *\n * @param {Number} number to evaluate.\n * @return {Boolean} return true if value is prime. false otherwise.\n */\nprime.simple = function (n) {\n    if (isNaN(n) || !isFinite(n) || n % 1 || n < 2) {\n        return false;\n    }\n    if (n % 2 === 0){\n        return (n === 2);\n    }\n    if (n % 3 === 0){\n        return (n === 3);\n    }\n    for (var i = 5, m = Math.sqrt(n); i <= m; i += 6) {\n        if ((n % i === 0) || (n % (i + 2) === 0)){\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns the prime factors of a number.\n * More info (http://bateru.com/news/2012/05/code-of-the-day-javascript-prime-factors-of-a-number/)\n * Taken from Ratio.js\n *\n * @param {Number} num\n * @return {Array} an array of numbers\n * @example prime.factorization(20).join(',') === \"2,2,5\"\n **/\nprime.factorization = function (num) {\n  num = Math.floor(num);\n  var root;\n  var factors = [];\n  var x;\n  var sqrt = Math.sqrt;\n  var doLoop = 1 < num && isFinite(num);\n  \n  while (doLoop) {\n    root = sqrt(num);\n    x = 2;\n    if (num % x) {\n      x = 3;\n      while ((num % x) && ((x += 2) < root)) {}\n    }\n    \n    x = (root < x) ? num : x;\n    factors.push(x);\n    doLoop = (x !== num);\n    num /= x;\n  }\n\n  return factors;\n};\n\n/**\n * Determine if a number is prime in Polynomial time, using a randomized algorithm. \n * http://en.wikipedia.org/wiki/Miller-Rabin_primality_test\n *\n * @param {Number} number to Evaluate.\n * @param {Number} number to Determine accuracy rate (number of trials) default value = 20.\n * @return {Boolean} return true if value is prime. false otherwise.\n */\nprime.millerRabin = function(n, k) {\n  if (arguments.length === 1) k = 20;\n  if (n === 2) return true;\n  if (!basic.isInt(n) || n <= 1 || n % 2 === 0) return false;\n\n  var s = 0;\n  var d = n - 1;\n\n  while (true) {\n    var dm = basic.divMod(d, 2);\n    var quotient = dm[0];\n    var remainder = dm[1];\n\n    if (remainder === 1) break;\n\n    s += 1;\n    d = quotient;\n  }\n\n  var tryComposite = function (a) {\n    if (basic.powerMod(a, d, n) === 1) return false;\n    \n    for (var i = 0; i < s; i ++) {\n      if (basic.powerMod(a, Math.pow(2, i) * d, n) === n - 1) return false;\n    }\n    \n    return true;\n  };\n\n  for (var i = 0; i < k; i++) {\n    var a = 2 + Math.floor(Math.random() * (n - 2 - 2));\n    if (tryComposite(a)) return false;\n  }\n\n  return true;\n};\n\n/**\n * Return a list of prime numbers from 1...n, inclusive.\n *\n * @param {Number} upper limit of test n.\n * @return {Array} list of values that are prime up to n.\n */ \nprime.sieve = function (n) {\n  if (n < 2) return [];\n  var result = [2];\n  for (var i = 3; i <= n; i++) {\n    var notMultiple = false;\n    \n    for (var j in result) { \n      notMultiple = notMultiple || (0 === i % result[j]); \n    }\n\n    if (!notMultiple) {\n      result.push(i);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Determine if two numbers are coprime.\n *\n * @param {Number} number.\n * @param {Number} number.\n * @return {Boolean} whether the values are coprime or not.\n */\nprime.coprime = function (a, b) {\n  return basic.gcd(a, b) === 1;\n};\n\n/**\n * Determine if a number is a perfect power.\n * Please note that this method does not find the minimal value of k where\n * m^k = n\n * http://en.wikipedia.org/wiki/Perfect_power\n *\n * @param {Number} value in question\n * @return {Array|Boolean} [m, k] if it is a perfect power, false otherwise\n */\nprime.getPerfectPower = function(n) {\n  var test = prime.getPrimePower(n);\n  if (test && test[1] > 1) return test;\n  return false;\n};\n\n/**\n * Determine if a number is a prime power and return the prime and the power.\n * http://en.wikipedia.org/wiki/Prime_power\n *\n * @param {Number} value in question\n * @return {Array|Boolean}  if it is a prime power, return [prime, power].\n */\nprime.getPrimePower = function(n) {\n  if (n < 2) return false;\n  if (prime.millerRabin(n)) return [n, 1]; \n  if (n % 2 === 0) return [2, n.toString(2).length - 1];\n\n  var factors = prime.factorization(n);\n\n  if (!factors) return false;\n  \n  var len = factors.length;\n  \n  for (var i = 0; i < len; i++) {\n    var t = 0, p = 0;\n\n    while (t <= n) {\n      t = Math.pow(factors[i], p);\n      if (t / n === 1) return [factors[i], p];\n      p++; \n    }\n  }\n\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/statistic.js":"/**\n * statistic.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar basic = require('./basic');\nvar statistic = exports;\n\n/**\n * Calculate the mean value of a set of numbers in array.\n *\n * @param {Array} set of values.\n * @return {Number} mean value.\n */\nstatistic.mean = function (arr) {\n  var count = arr.length;\n  var sum = basic.sum(arr);\n  return sum / count;\n};\n\n/**\n * Calculate the median value of a set of numbers in array.\n *\n * @param {Array} set of values.\n * @return {Number} median value.\n */\nstatistic.median = function (arr) {\n  return statistic.quantile(arr, 1, 2);\n};\n\n/**\n * Calculate the mode value of a set of numbers in array.\n *\n * @param {Array} set of values.\n * @return {Number} mode value.\n */\nstatistic.mode = function (arr) {\n  var counts = {};\n  for (var i = 0, n = arr.length; i < n; i++) {\n    if (counts[arr[i]] === undefined) {\n      counts[arr[i]] = 0;\n    } else {\n      counts[arr[i]]++;\n    }\n  }\n\n  var highest;\n\n  for (var number in counts) {\n    if (counts.hasOwnProperty(number)) {\n      if (highest === undefined || counts[number] > counts[highest]) {\n        highest = number;\n      }\n    }\n  }\n\n  return Number(highest);\n};\n\n/**\n * Calculate the kth q-quantile of a set of numbers in an array.\n * As per http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population\n * Ex: Median is 1st 2-quantile\n * Ex: Upper quartile is 3rd 4-quantile\n *\n * @param {Array} set of values.\n * @param {Number} index of quantile.\n * @param {Number} number of quantiles.\n * @return {Number} kth q-quantile of values.\n */\nstatistic.quantile = function (arr, k, q) {\n  var sorted, count, index;\n\n  if (k === 0) return Math.min.apply(null, arr);\n\n  if (k === q) return Math.max.apply(null, arr);\n\n  sorted = arr.slice(0);\n  sorted.sort(function (a, b) { return a - b; });\n  count = sorted.length;\n  index = count * k / q;\n\n  if (index % 1 === 0) return 0.5 * sorted[index - 1] + 0.5 * sorted[index];\n\n  return sorted[Math.floor(index)];\n};\n\n\n/**\n * Return a set of summary statistics provided an array.\n *\n * @return {Object} summary statistics.\n */\nstatistic.report = function(array) {\n  return {\n    mean: statistic.mean(array),\n    firstQuartile: statistic.quantile(array, 1, 4),\n    median: statistic.median(array),\n    thirdQuartile: statistic.quantile(array, 3, 4),\n    standardDev: statistic.standardDev(array)\n  };\n};\n\n/**\n * Evaluate the standard deviation for a set of values.\n *\n * @param {Array} set of values.\n * @return {Number} standard deviation.\n */\nstatistic.standardDev = function (arr) {\n  var count = arr.length;\n  var mean = statistic.mean(arr);\n  var squaredArr = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    squaredArr[i] = Math.pow((arr[i] - mean),2);\n  }\n\n  return Math.sqrt((1 / count) * basic.sum(squaredArr));\n};\n\n/**\n * Evaluate the correlation amongst a set of values.\n *\n * @param {Array} set of values.\n * @return {Number} correlation.\n */\nstatistic.correlation = function (arrX, arrY) {\n  if (arrX.length == arrY.length) {\n    var covarXY = statistic.covariance(arrX, arrY);\n    var stdDevX = statistic.standardDev(arrX);\n    var stdDevY = statistic.standardDev(arrY);\n\n    return covarXY / (stdDevX * stdDevY);\n  } else {\n    throw new Error('Array mismatch');\n  }\n};\n\n/**\n * Calculate the Coefficient of Determination of a dataset and regression line.\n *\n * @param {Array} Source data.\n * @param {Array} Regression data.\n * @return {Number} A number between 0 and 1.0 that represents how well the regression line fits the data.\n */\nstatistic.rSquared = function (source, regression) {\n  var residualSumOfSquares = basic.sum(source.map(function (d,i) {\n    return basic.square(d - regression[i]);\n  }));\n\n  var totalSumOfSquares = basic.sum(source.map(function (d) {\n    return basic.square(d - statistic.mean(source));\n  }));\n\n  return 1 - (residualSumOfSquares / totalSumOfSquares);\n};\n\n/**\n * Create a function to calculate the exponential regression of a dataset.\n *\n * @param {Array} set of values.\n * @return {Function} function to accept X values and return corresponding regression Y values.\n */\nstatistic.exponentialRegression = function (arrY) {\n  var n = arrY.length;\n  var arrX = basic.range(1,n);\n\n  var xSum = basic.sum(arrX);\n  var ySum = basic.sum(arrY);\n  var yMean = statistic.mean(arrY);\n  var yLog = arrY.map(function (d) { return Math.log(d); });\n  var xSquared = arrX.map(function (d) { return d * d; });\n  var xSquaredSum = basic.sum(xSquared);\n  var yLogSum = basic.sum(yLog);\n  var xyLog = arrX.map(function (d, i) { return d * yLog[i]; });\n  var xyLogSum = basic.sum(xyLog);\n\n  var a = (yLogSum * xSquaredSum - xSum * xyLogSum) / (n * xSquaredSum - (xSum * xSum));\n  var b = (n * xyLogSum - xSum * yLogSum) / (n * xSquaredSum - (xSum * xSum));\n\n  var fn = function(x) {\n    if (typeof x === 'number') {\n      return Math.exp(a) * Math.exp(b * x);\n    } else {\n      return x.map(function (d) {\n        return Math.exp(a) * Math.exp(b * d);\n      });\n    }\n  };\n\n  fn.rSquared = statistic.rSquared(arrY, arrX.map(fn));\n\n  return fn;\n};\n\n/**\n * Create a function to calculate the linear regression of a dataset.\n *\n * @param {Array} X array.\n * @param {Array} Y array.\n * @return {Function} A function which given X or array of X values will return Y.\n */\nstatistic.linearRegression = function (arrX, arrY) {\n  var n = arrX.length;\n  var xSum = basic.sum(arrX);\n  var ySum = basic.sum(arrY);\n  var xySum = basic.sum(arrX.map(function (d, i) { return d * arrY[i]; }));\n  var xSquaredSum = basic.sum(arrX.map(function (d) { return d * d; }));\n  var xMean = statistic.mean(arrX);\n  var yMean = statistic.mean(arrY);\n  var b = (xySum - 1 / n * xSum * ySum) / (xSquaredSum - 1 / n * (xSum * xSum));\n  var a = yMean - b * xMean;\n\n  return function(x) {\n    if (typeof x === 'number') {\n      return a + b * x;\n    } else {\n      return x.map(function (d) {\n        return a + b * d;\n      });\n    }\n  };\n};\n\n/**\n * Evaluate the covariance amongst 2 sets.\n *\n * @param {Array} set 1 of values.\n * @param {Array} set 2 of values.\n * @return {Number} covariance.\n */\n statistic.covariance = function (set1, set2) {\n  if (set1.length == set2.length) {\n    var n = set1.length;\n    var total = 0;\n    var sum1 = basic.sum(set1);\n    var sum2 = basic.sum(set2);\n\n    for (var i = 0; i < n; i++) {\n      total += set1[i] * set2[i];\n    }\n\n    return (total - sum1 * sum2 / n) / n;\n  } else {\n    throw new Error('Array mismatch');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/generators.js":"/**\n * generators.js\n * http://github.com/sjkaliski/numbers.js\n *\n * Copyright 2012 Stephen Kaliski, Kartik Talwar\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar generate = exports;\n\n/**\n * Fast Fibonacci Implementation\n *\n * @param {Number} number to calculate\n * @return {Number} nth fibonacci number\n */\ngenerate.fibonacci = function (n) {\n  // Adapted from\n  // http://bosker.wordpress.com/2011/04/29/the-worst-algorithm-in-the-world/\n\n  var bitSystem = function(n) {\n    var bit, bits = [];\n\n    while (n > 0) {\n      bit = (n < 2) ? n : n % 2;\n      n = Math.floor(n / 2);\n      bits.push(bit);\n    }\n    \n    return bits.reverse();\n  };\n\n  var a = 1;\n  var b = 0;\n  var c = 1;\n  var system = bitSystem(n);\n  var temp;\n  \n  for (var i = 0; i < system.length; i++) {\n    var bit = system[i];\n    if (bit) {\n      temp = [(a + c) * b, (b * b) + (c * c)];\n      a = temp[0];\n      b = temp[1];\n    } else {\n      temp = [(a * a) + (b * b), (a + c) * b];\n      a = temp[0];\n      b = temp[1];\n    }\n\n    c = a + b;\n  }\n\n  return b;\n};\n\n/**\n * Populate the given array with a Collatz Sequence.\n *\n * @param {Number} first number.\n * @param {Array} arrary to be populated.\n * @return {Array} array populated with Collatz sequence\n */\ngenerate.collatz = function (n, result) {\n  result.push(n);\n  \n  if (n === 1) {\n    return;\n  } else if (n % 2 === 0) {\n    generate.collatz(n / 2, result);\n  } else {\n    generate.collatz(3 * n + 1, result);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/lib/numbers/random.js":"var basic = require('./basic');\nvar random = exports;\n\n// random number generator.\nvar rGen = Math.random;\n\n/**\n * Set the pseudo random number generator used by the random module.\n *\n * @param {Function} Random number generator\n */\nrandom.setGenerator = function(fn){\n  if(typeof fn !== \"function\"){\n    throw new Error(\"Must pass a function\");\n  }\n  rGen = fn;\n};\n/**\n * Return a random sample of values over a set of bounds with\n * a specified quantity.\n *\n * @param {Number} lower bound.\n * @param {Number} upper bound.\n * @param {Number} quantity of elements in random sample.\n * @return {Array} random sample.\n */\nrandom.sample = function (lower, upper, n) {\n  var sample = [];\n  sample.length = n;\n\n  for (var i=0; i<n; i++) {\n    sample[i] = lower + (upper - lower) * rGen();\n  }\n  return sample;\n};\n\n/**\n * A pseudo-random number sampling method for generating pairs of independent,\n * standard, normally distributed (zero expectation, unit variance) random\n * numbers, given a source of uniformly distributed random numbers.\n * http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n *\n * @param {Number} mu or mean\n * @param {Number} sigma or standard deviation\n * @return {Number} a value that is part of a normal distribution.\n */\nrandom.boxMullerTransform = function(mu, sigma) {\n  if (arguments.length <= 1) sigma = 1;\n  if (arguments.length === 0) mu = 0;\n  var u = 0,\n      v = 0,\n      s;\n\n  do {\n    u = rGen() * 2 - 1;\n    v = rGen() * 2 - 1;\n    s = u * u + v * v;\n  } while (s === 0 || s > 1);\n\n  var c = Math.sqrt(-2 * Math.log(s)/s),\n      x = u * c,\n      y = v * c;\n  x = mu + x * sigma;\n  y = mu + y * sigma;\n  return [x, y];\n};\n\n/**\n * A Random number that is along an irwin hall distribution.\n * http://en.wikipedia.org/wiki/Irwin-Hall_distribution\n *\n * @param {Number} max possible sum\n * @param {Number} number to subtract\n * @return {Number} random number along an irwin hall distribution.\n */\nrandom.irwinHall = function(n, sub) {\n  if (arguments.length === 1) sub = 0;\n  var sum = 0;\n  for (var i = 0; i < n; i++) sum += rGen();\n  return sum - sub;\n};\n\n/**\n * Returns a random value along a bates distribution from [a, b] or [0, 1].\n * http://en.wikipedia.org/wiki/Bates_distribution\n *\n * @param {Number} number of times summing\n * @param {Number} random maximum value (default is 1)\n * @param {Number} random minimum value (default is 0)\n * @return {Number} random number along an bates distribution.\n */\nrandom.bates = function(n, b, a) {\n  if (arguments.length <= 2) a = 0;\n  if (arguments.length === 1) b = 1;\n  var sum = 0;\n  for (var i = 0; i < n; i++) sum += (b - a)*rGen() + a;\n  return sum/n;\n};\n\nrandom.distribution = {};\n\n/**\n * Returns an array of size n that is an approximate normal distribution\n *\n * @param {Number} n size of returned array\n * @param {Number} mu or mean\n * @param {Number} sigma or standard deviation\n * @return {Array} array of size n of a normal distribution\n */\nrandom.distribution.normal = function(n, mu, sigma) {\n  if (arguments.length <= 2) sigma = 1;\n  if (arguments.length === 1) mu = 0;\n\n  return random.distribution.boxMuller(n, mu, sigma);\n};\n\n/**\n * Returns an array of size n that is an approximate log normal distribution\n *\n * @param {Number} n size of returned array\n * @param {Number} mu or mean\n * @param {Number} sigma or standard deviation\n * @return {Array} array of size n of a log normal distribution\n */\nrandom.distribution.logNormal = function(n, mu, sigma) {\n  if (arguments.length <= 2) sigma = 1;\n  if (arguments.length === 1) mu = 0;\n\n  var exponential = function(x) {\n    return Math.exp(x);\n  };\n\n  return random.distribution.boxMuller(n, mu, sigma).map(exponential);\n};\n\n/**\n * Returns an array of size n that is a normal distribution\n * leveraging the Box Muller Transform\n * http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n *\n * @param {Number} n size of returned array\n * @param {Number} mu or mean\n * @param {Number} sigma or standard deviation\n * @param {Number} determine if the distribution will be polar coordinates.\n * @return {Array} array of size n of a normal distribution\n */\nrandom.distribution.boxMuller = function(n, mu, sigma, rc) {\n  if (arguments.length <= 3) rc = false;\n  if (arguments.length <= 2) sigma = 1;\n  if (arguments.length === 1) mu = 0;\n  var results = [];\n\n  for (var i = 0; i < n; i++) {\n    var randomBMT = random.boxMullerTransform(mu, sigma);\n    results.push((rc) ? randomBMT : randomBMT[0]);\n  }\n\n  return results;\n};\n\n/**\n * Returns an array of n that is an irwin hall distribution.\n * http://en.wikipedia.org/wiki/Irwin-Hall_distribution\n *\n * @param {Number} length of array\n * @param {Number} irwinHall max sum value (default is n)\n * @param {Number} irwinHall subtraction value (default is 0)\n * @return {Array} irwin hall distribution from [a, b]\n */\nrandom.distribution.irwinHall = function(n, m, sub) {\n  if (arguments.length <= 2) sub = 0;\n  if (arguments.length === 1) m = n;\n  var results = new Array(n);\n  for (var i = 0; i < n; i++) {\n    results[i] = random.irwinHall(m, sub);\n  }\n\n  return results;\n};\n\n/**\n * An approach to create a normal distribution,\n * that relies on the central limit theorem,\n * resulting in an approximately standard normal distribution\n * with bounds of (-6, 6)\n *\n * @param {Number} length of array\n * @return {Array} an array of an approximate normal distribution from [-6, 6] of length n.\n */\nrandom.distribution.irwinHallNormal = function(n) {\n  return random.distribution.irwinHall(n, 12, 6);\n};\n\n/**\n * Returns an array of n that is a bates distribution from\n * http://en.wikipedia.org/wiki/Bates_distribution\n *\n * @param {Number} length of array\n * @param {Number} max bates value (default is n)\n * @param {Number} minimum bound a (default is 0)\n * @return {Array} bates distribution from [a, b]\n */\nrandom.distribution.bates = function(n, b, a) {\n  if (arguments.length <= 2) a = 0;\n  if (arguments.length === 1) b = n;\n\n  var results = new Array(n);\n\n  for (var i = 0; i < n; i++) {\n    results[i] = random.bates(n, b, a);\n  }\n\n  return results;\n};\n","/home/travis/build/npmtest/node-npmtest-numbers/node_modules/numbers/gulpfile.js":"var browserify = require(\"browserify\");\nvar buffer = require(\"vinyl-buffer\");\nvar del = require(\"del\");\nvar gulp = require(\"gulp\");\nvar jshint = require(\"gulp-jshint\");\nvar jshintStylish = require(\"jshint-stylish\");\nvar mocha = require(\"gulp-mocha\");\nvar prettify = require(\"gulp-jsbeautifier\");\nvar rename = require(\"gulp-rename\");\nvar source = require(\"vinyl-source-stream\");\nvar uglify = require(\"gulp-uglify\");\n\nvar DEST = \"./src\";\n\ngulp.task(\"build\", [ \"minimize\" ]);\n\ngulp.task(\"clean:src\", function(cb){\n  del([\n    DEST\n  ], cb );\n});\n\ngulp.task(\"concat\", [ \"clean:src\" ], function(){\n  return browserify(\"./index.js\", { standalone : \"numbers\" })\n    .bundle()\n    .pipe(source(\"numbers.js\"))\n    .pipe(gulp.dest( DEST ));\n});\n\ngulp.task(\"default\", [ \"build\" ]);\n\ngulp.task(\"format:lib\", function(){\n  return gulp.src( [\"./lib/**/*.js\"], { base : \"./lib\"} )\n    .pipe(prettify())\n    .pipe(gulp.dest(\"./lib\"));\n});\n\ngulp.task(\"format:test\", function(){\n  return gulp.src( [\"./test/*.js\"], { base : \"./\"} )\n    .pipe(prettify())\n    .pipe(gulp.dest(\"./\"));\n});\n\ngulp.task(\"format\", [ \"format:lib\", \"format:test\" ]);\n\ngulp.task(\"lint\", function(){\n  return gulp.src( [\"./lib/**/*.js\", \"./test/*.js\"] )\n    .pipe(jshint())\n    .pipe(jshint.reporter(jshintStylish));\n});\n\ngulp.task(\"minimize\", [ \"concat\" ], function(){\n  return gulp.src( DEST + \"/numbers.js\")\n    .pipe(uglify())\n    .pipe(rename({ extname : \".min.js\" }))\n    .pipe(gulp.dest( DEST ));\n});\n\ngulp.task(\"test\", function(){\n  return gulp.src([\"./test/*.js\", \"!./test/testing.js\"])\n    .pipe(mocha({ \n       ui : \"tdd\"\n     }));\n});\n\n"}